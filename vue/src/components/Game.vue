<template>
  <div align="center" v-bind:class="[ gameResultClass ]">
    <div id="controlbar">
      <v-text-field
        outlined
        label="width/height"
        placeholder="10"
        id="difficulty"
        value="width"
        v-model="mutableDifficulty"
        @change="$emit('resetButtonEvent:difficulty', mutableDifficulty)" />
      <v-text-field
        outlined
        label="bomb percentage"
        placeholder="50%"
        id="percentage"
        value="percent"
        v-model="mutablePercentage"
        @change="$emit('resetButtonEvent:percent', mutablePercentage)"/>
      <!--
      <v-checkbox
        id="showCheckbox"
        v-model="mutableShow" tooltip/>
      <v-btn
        id="resetButton"
        large
        outlined
        @click="$emit('resetButtonEvent')">RESET</v-btn>
      -->
    </div>
    <div id="stats">
      <v-chip
        label
        outlined
        color="green"
      >
        <v-icon left color="green">mdi-square</v-icon>
        {{ this.spaces }}
      </v-chip>
      <v-chip
        label
        outlined
        color="red"
      >
        <v-icon left>mdi-bomb</v-icon>
        {{ this.numberOfBombsToPlace }}
      </v-chip>
    </div>
    <div id="gameboard" class="gameboard">
      <table v-bind:class="['game', lose ? 'isNotClickable' : '']">
        <tbody>
          <tr v-for="(row, rowIndex) in initializedGameBoard" :key="row.id">
            <td v-for="cell in row" :key="cell.id">
              <div v-if="mutableShow">
                <span class="secret">{{ cell.value }}</span>
              </div>
              <Cell
                :width="width"
                :row="rowIndex"
                :mine="cell.value"
                :index="cell.index"
                :adjacents="cell.adjacents"
                :adjacentCellIndexes="cell.adjacentCellIndexes"
                @click.native="clickHandler"
              />
            </td>
          </tr>
        </tbody>
      </table>
      <div id="reset-control" v-if="lose">
        <v-btn
        id="resetButton"
        large
        outlined
        @click="$emit('resetButtonEvent')">RESET</v-btn>
      </div>
      <Timer/>
    </div>
  </div>
</template>
<style>
  table {
    background-color: black;
    border-spacing: 0px;
  }
  div#controlbar {
    width: 300px;
    display: flex;
  }
  div#reset-control {
    padding-top: 10px;
    padding-bottom: 10px;
  }
  div#stats {
    padding-bottom: 10px;
  }
  #controlbar .v-text-field__slot {
    font-size: 40px;
  }
  #controlbar .v-text-field {
    width: 20px;
  }
  td {
    border: 0px solid black;
    margin: 0px;
    padding: 0px;
    width: 25px;
    height: 25px;
  }
  span.secret {
    position: absolute; 
    font-size: x-small;
    color: lightgray;
  }
  .gameboard {
    width: fit-content;
  }
  .isNotClickable {
    pointer-events: none;
  },
  .puff-out-center {
  -webkit-animation: puff-out-center 1s cubic-bezier(0.165, 0.840, 0.440, 1.000) both;
          animation: puff-out-center 1s cubic-bezier(0.165, 0.840, 0.440, 1.000) both;
}
/* ----------------------------------------------
 * Generated by Animista on 2019-7-26 10:35:14
 * w: http://animista.net, t: @cssanimista
 * ---------------------------------------------- */

/**
 * ----------------------------------------
 * animation puff-out-center
 * ----------------------------------------
 */
@-webkit-keyframes puff-out-center {
  0% {
    -webkit-transform: scale(1);
            transform: scale(1);
    -webkit-filter: blur(0px);
            filter: blur(0px);
    opacity: 1;
  }
  100% {
    -webkit-transform: scale(2);
            transform: scale(2);
    -webkit-filter: blur(2px);
            filter: blur(2px);
    opacity: 0;
  }
}
@keyframes puff-out-center {
  0% {
    -webkit-transform: scale(1);
            transform: scale(1);
    -webkit-filter: blur(0px);
            filter: blur(0px);
    opacity: 1;
  }
  100% {
    -webkit-transform: scale(2);
            transform: scale(2);
    -webkit-filter: blur(2px);
            filter: blur(2px);
    opacity: 0;
  }
}

</style>
<script>
  import Vue from 'vue'
  import Cell from './Cell.vue'
  import Timer from './Timer.vue'
  import Vuetify from 'vuetify/lib'

  Vue.use(Vuetify);

  Array.prototype.unique = function() {
        var a = this.concat();
        for(var i=0; i<a.length; ++i) {
            for(var j=i+1; j<a.length; ++j) {
                if(a[i] === a[j])
                    a.splice(j--, 1);
            }
        }

        return a;
      };

  export default {
    name: 'gameboard',
    components: {
      Cell,
      Timer
    },
    props: {
      width: Number,
      percent: Number,
      show: Boolean
    },
    data: function () {
      return {
        spaces: this.width*this.width,
        numberOfBombsToPlace: Math.floor((this.width*this.width)*(this.percent/100)),
        mutableShow: this.show,
        mutableDifficulty: this.width,
        mutablePercentage: this.percent,
        exploded: false,
        regions: null,
        revealed: [],
        started: false,
        lose: false
      }
    },
    computed: {
      initializedGameBoard: function() {
        return this.arrangeIntoRowsCols(this.randomlyMixBombs(this.numberOfBombsToPlace, this.spaces));
      },
      gameResultClass: function() {
        return this.lose ? '' : '';
      }
    },
    methods: {
      randomlyMixBombs(bombCount, spaces) {
        let board = new Array(bombCount).fill('o');
        for(let length = board.length; board.length < spaces; length++) {
          let randomPosition = length - Math.floor(Math.random() * length);
          board.splice(randomPosition, 0, 'x');
        }
        return this.calculateAdjacencies(board);
      },
      getRegionIndexes(region, width) {
        switch (region) {
          case 'top':
            return new Array(width-2).fill().map((e, i) => {
              return i+1;
            });
          case 'right':
            return new Array(width-2).fill().map((e, i) => {
              return width*(i+2)-1;
            });
          case 'left':
            return new Array(width-2).fill().map((e, i) => {
              return width*(i+1);
            });
          case 'bottom':
            return new Array(width-2).fill().map((e, i) => {
              return width*width-(width-i-1);
            });
          case 'topleftcorner': return 0;
          case 'toprightcorner': return width-1;
          case 'bottomleftcorner': return width*width-(width);
          case 'bottomrightcorner': return width*width-1;
        }
      },
      calculateAdjacencies(board) {
        let self = this;
        function getPositionOffsetsForCell(cellIndex) {
          if (self.regions.innerCells.find(cell => cell === cellIndex)) {
            return positionOffsets;
          } else {
            let region = Object.entries(self.regions).filter(region => !region[0].match(/(outerCells|innerCells)/)).find(region => {
              let regionCells = (region[1].cells instanceof Array) ? region[1].cells : [ region[1].cells ];
              if (regionCells.find(cell => cell === cellIndex) !== undefined) return true;
            });
            return region[1].offsets;
          }
        }
        let width = Math.sqrt(board.length);
        let positionOffsets = {
          left: -1,
          lefttop: -(width+1),
          top: -width,
          righttop: -(width-1),
          right: 1,
          rightbottom: width+1,
          bottom: width,
          leftbottom: width-1
        }
        this.regions = {
          top: {
            cells: this.getRegionIndexes('top', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(lefttop|top|righttop)/)))
          },
          right: {
            cells: this.getRegionIndexes('right', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(right|righttop|rightbottom)/)))
          },
          bottom: {
            cells: this.getRegionIndexes('bottom', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(rightbottom|bottom|leftbottom)/)))
          },
          left: {
            cells: this.getRegionIndexes('left', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(left|lefttop|leftbottom)/)))
          },
          topleftcorner: {
            cells: this.getRegionIndexes('topleftcorner', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(leftbottom|left|lefttop|top|righttop)/)))
          },
          toprightcorner: {
            cells: this.getRegionIndexes('toprightcorner', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(lefttop|top|righttop|right|rightbottom)/)))
          },
          bottomleftcorner: {
            cells: this.getRegionIndexes('bottomleftcorner', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(lefttop|left|leftbottom|bottom|rightbottom)/)))
          },
          bottomrightcorner: {
            cells: this.getRegionIndexes('bottomrightcorner', width),
            offsets: Object.fromEntries(Object.entries(positionOffsets).filter(e => !e[0].match(/(leftbottom|bottom|rightbottom|right|righttop)/)))
          }
        }
        //let board = new Array(this.width*this.width).fill();
        this.regions.outerCells = Object.values(this.regions).map(r => r.cells).flatMap(cell => cell).sort((a,b) => a-b);
        this.regions.innerCells = board.map((cell, i) => this.regions.outerCells.find(i2 => i === i2) ? 0 : i).filter(cell => cell !== 0)
        // Need to do this for each of the regions.  Thus I need to calculate the center region.
        board = board.flatMap((cell, index, cells) => {
          let adjacents = [],
            adjacentCellIndexes = [],
            positionOffsetsForCell = getPositionOffsetsForCell(index);

          Object.entries(positionOffsetsForCell).map((offset, i, offsets) => {
            let position = index + parseInt(offset[1]);
            if (cells[position] === 'o') {
              adjacents.push(offset);
            }
            adjacentCellIndexes.push(position);
            if (i === offsets.length-1) return adjacents;
          });
          return {
            value: cell,
            adjacents,
            adjacentCellIndexes
          };
        });
        return board;
      },
      arrangeIntoRowsCols(board) {
        let width = Math.sqrt(board.length),
          board2 = new Array(width).fill().map(() => new Array(width).fill());
        for(let index = 0, row = 0, col = 0; index < board.length; index++) {
          board2[row][col] = Object.assign(board[index], { index });
          if ((index+1)%width === 0) {
            row++;
            col = 0;
          } else {
            col++;
          }
        }
        return board2;
      },
      getCellByIndex(index) {
        let cells = Array.from(document.querySelectorAll('div.cell')).map(e => e.__vue__);
        let cell = cells.find(cell => cell.index === index);
        return cell;
      },
      clickHandler(event) {
        let cell = event.target;
        this.started ? '' : document.querySelector('#timer').__vue__.start();
        this.reveal(cell.__vue__);
      },
      explodeAllMines() {
        Array.from(document.querySelectorAll('div.cell')).map(e => e.__vue__.explode());
        this.lose = true;
      },
      reveal(cell) {
        let self = this;
        cell.reveal();
        if (cell.mine === 'o') {
          this.explodeAllMines();
          document.querySelector('#timer').__vue__.stop();
          this.mutableShow = true;
        } else if (cell.mine === 'x' && cell.adjacents.length === 0) {
          cell.adjacentCellIndexes.forEach(cellIndex => {
            if (self.revealed.find(index => index === cellIndex) === undefined) {
              self.revealed.push(cellIndex);
              self.reveal(self.getCellByIndex(cellIndex), cellIndex);
            }      
          });
          // Uncover adjacent mines 
        }
      }
    }
  };
</script>